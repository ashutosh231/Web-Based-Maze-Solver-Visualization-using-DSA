<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            font-family: 'Inter', sans-serif;
        }

        /* Dynamic Background Animation */
        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: -2;
            overflow: hidden;
        }

        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
        }

        /* Floating shapes */
        .shape {
            position: absolute;
            background: rgba(255, 255, 255, 0.05);
            animation: floatShape 15s infinite ease-in-out;
        }

        @keyframes floatShape {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        /* Glass morphism effect */
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        /* Enhanced grid styles - FIXED */
        .grid-container {
            perspective: 1000px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            display: inline-block;
            margin: 0 auto;
        }

        .cell {
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: inline-block;
            margin: 0px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .cell:hover::before {
            transform: translateX(100%);
        }

        .cell:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .start {
            background: linear-gradient(135deg, #4CAF50, #45a049) !important;
            border: 3px solid #2E7D32 !important;
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.8), inset 0 0 15px rgba(255, 255, 255, 0.2);
            animation: pulse 2s infinite;
        }

        .end {
            background: linear-gradient(135deg, #F44336, #d32f2f) !important;
            border: 3px solid #C62828 !important;
            box-shadow: 0 0 25px rgba(244, 67, 54, 0.8), inset 0 0 15px rgba(255, 255, 255, 0.2);
            animation: pulse 2s infinite;
        }

        .wall {
            background: linear-gradient(135deg, #424242, #212121) !important;
            border: 3px solid #1A1A1A !important;
            transform: scale(0.95);
            border-radius: 4px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }

        .visited {
            background: linear-gradient(135deg, #2196F3, #1976D2) !important;
            border: 3px solid #1565C0 !important;
            animation: visitedAnimation 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.6);
        }

        .path {
            background: linear-gradient(135deg, #FFEB3B, #FFC107) !important;
            border: 3px solid #FF8F00 !important;
            animation: pathAnimation 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 20px rgba(255, 235, 59, 0.8);
        }

        .current {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2) !important;
            border: 3px solid #4A148C !important;
            animation: currentAnimation 1s infinite;
            box-shadow: 0 0 25px rgba(156, 39, 176, 1);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes visitedAnimation {
            0% {
                transform: scale(0.3) rotateZ(0deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.3) rotateZ(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotateZ(360deg);
                opacity: 1;
            }
        }

        @keyframes pathAnimation {
            0% {
                transform: scale(0.3) rotateY(0deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.4) rotateY(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotateY(360deg);
                opacity: 1;
            }
        }

        @keyframes currentAnimation {
            0%, 100% { 
                transform: scale(1) rotateZ(0deg);
                box-shadow: 0 0 25px rgba(156, 39, 176, 1);
            }
            50% { 
                transform: scale(1.2) rotateZ(180deg);
                box-shadow: 0 0 35px rgba(156, 39, 176, 1);
            }
        }

        /* Enhanced buttons */
        .btn {
            position: relative;
            overflow: hidden;
            transform: translateZ(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Cards with glass effect */
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 16px 40px rgba(31, 38, 135, 0.5);
        }

        /* Enhanced statistics */
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.02);
        }

        /* Loading animation */
        .loading {
            position: relative;
            overflow: hidden;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: loading 2s infinite;
        }

        @keyframes loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Enhanced controls */
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .cell {
                width: 24px;
                height: 24px;
            }
            
            .particles {
                display: none;
            }
            
            .grid-container {
                padding: 20px;
            }
        }

        /* Speed slider enhancement */
        .speed-slider {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 8px;
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        /* Enhanced text styling */
        .text-glow {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Algorithm info cards */
        .algo-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .algo-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-3px);
        }

        /* Grid layout fix */
        .grid-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
            overflow-x: auto;
        }

        /* Credits footer styling */
        .credits-footer {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 2rem;
            padding: 2rem 0;
            text-align: center;
        }

        .credits-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .credits-names {
            display: flex;
            justify-content: center;
            gap: 3rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .developer-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .developer-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.15);
        }

        .developer-name {
            font-size: 1.25rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.5rem;
        }

        .developer-info {
            font-size: 0.9rem;
            color: #b0b0b0;
            margin-bottom: 0.25rem;
        }

        .university {
            font-size: 0.8rem;
            color: #8a8a8a;
            font-style: italic;
        }

        @media (max-width: 640px) {
            .credits-names {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
</head>
<body class="min-h-screen text-white overflow-x-hidden">
    <!-- Dynamic Background -->
    <div class="background-animation">
        <div class="particles" id="particles"></div>
        <div class="absolute inset-0">
            <div class="shape w-32 h-32 rounded-full top-10 left-10" style="animation-delay: 0s;"></div>
            <div class="shape w-24 h-24 rounded-lg top-1/3 right-20" style="animation-delay: 2s;"></div>
            <div class="shape w-20 h-20 rounded-full bottom-20 left-1/4" style="animation-delay: 4s;"></div>
            <div class="shape w-28 h-28 rounded-lg bottom-10 right-10" style="animation-delay: 6s;"></div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8 relative z-10">
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-5xl font-bold text-glow mb-4 bg-clip-text text-transparent bg-gradient-to-r from-white via-blue-100 to-white">
                Maze Solver Visualization
            </h1>
            <p class="text-xl text-gray-200 opacity-90">
                Visualizing BFS and DFS pathfinding algorithms with beautiful animations
            </p>
        </header>

        <!-- Main Content -->
        <div class="card p-8 mb-8">
            <div class="flex flex-col xl:flex-row gap-8">
                <!-- Grid Section -->
                <div class="flex-1">
                    <div class="control-group mb-6">
                        <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                            <div class="flex items-center space-x-4">
                                <label for="grid-size" class="font-medium text-gray-200">Grid Size:</label>
                                <select id="grid-size" class="glass px-4 py-2 rounded-lg text-white bg-transparent border-0 focus:ring-2 focus:ring-blue-400 transition-all">
                                    <option value="10" class="bg-gray-800">10x10</option>
                                    <option value="15" class="bg-gray-800" selected>15x15</option>
                                    <option value="20" class="bg-gray-800">20x20</option>
                                    <option value="25" class="bg-gray-800">25x25</option>
                                </select>
                            </div>
                            <button id="generate-maze" class="btn bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-6 py-2 rounded-lg font-medium">
                                🎲 Generate Maze
                            </button>
                        </div>
                    </div>

                    <div class="grid-wrapper mb-6">
                        <div class="grid-container">
                            <!-- Grid will be generated here -->
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-4">
                            <button id="add-start" class="btn bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white px-4 py-2 rounded-lg font-medium">
                                🏁 Start
                            </button>
                            <button id="add-end" class="btn bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white px-4 py-2 rounded-lg font-medium">
                                🎯 End
                            </button>
                            <button id="add-wall" class="btn bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white px-4 py-2 rounded-lg font-medium">
                                🧱 Wall
                            </button>
                            <button id="clear-walls" class="btn bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white px-4 py-2 rounded-lg font-medium">
                                🗑️ Clear
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="xl:w-96">
                    <div class="control-group mb-6">
                        <div class="flex items-center justify-between mb-4">
                            <label for="algorithm" class="font-medium text-gray-200">Algorithm:</label>
                            <select id="algorithm" class="glass px-4 py-2 rounded-lg text-white bg-transparent border-0 focus:ring-2 focus:ring-blue-400 transition-all">
                                <option value="bfs" class="bg-gray-800">🌊 Breadth-First Search</option>
                                <option value="dfs" class="bg-gray-800">🌳 Depth-First Search</option>
                            </select>
                        </div>

                        <div class="mb-4">
                            <label for="speed" class="block font-medium text-gray-200 mb-2">Speed Control</label>
                            <input type="range" id="speed" min="1" max="10" value="5" class="speed-slider w-full">
                            <div class="flex justify-between text-sm text-gray-300 mt-2">
                                <span>🐌 Slow</span>
                                <span>⚡ Fast</span>
                            </div>
                        </div>

                        <div class="control-group mb-4">
                            <div class="grid grid-cols-3 gap-3 mb-4">
                                <button id="start" class="btn bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white px-4 py-3 rounded-lg font-medium">
                                    ▶️ Start
                                </button>
                                <button id="pause" class="btn bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white px-4 py-3 rounded-lg font-medium" disabled>
                                    ⏸️ Pause
                                </button>
                                <button id="reset" class="btn bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white px-4 py-3 rounded-lg font-medium">
                                    🔄 Reset
                                </button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="grid grid-cols-3 gap-2 mb-4">
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-green-500 to-green-600 rounded mr-2"></div>
                                    <span class="text-sm">Start</span>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-red-500 to-red-600 rounded mr-2"></div>
                                    <span class="text-sm">End</span>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-gray-600 to-gray-700 rounded mr-2"></div>
                                    <span class="text-sm">Wall</span>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-blue-500 to-blue-600 rounded mr-2"></div>
                                    <span class="text-sm">Visited</span>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-purple-500 to-purple-600 rounded mr-2"></div>
                                    <span class="text-sm">Current</span>
                                </div>
                                <div class="flex items-center justify-center">
                                    <div class="w-4 h-4 bg-gradient-to-r from-yellow-400 to-yellow-500 rounded mr-2"></div>
                                    <span class="text-sm">Path</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Statistics -->
                    <div class="control-group">
                        <h3 class="font-semibold text-gray-200 mb-4 text-lg">📊 Statistics</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="stat-item">
                                <div class="text-sm text-gray-300">Steps</div>
                                <div id="steps" class="text-xl font-bold text-blue-400">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="text-sm text-gray-300">Visited</div>
                                <div id="visited-count" class="text-xl font-bold text-purple-400">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="text-sm text-gray-300">Path Length</div>
                                <div id="path-length" class="text-xl font-bold text-yellow-400">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="text-sm text-gray-300">Status</div>
                                <div id="status" class="text-lg font-bold text-green-400">Ready</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Algorithm Information -->
        <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="algo-card">
                <h3 class="text-2xl font-bold text-blue-400 mb-3">🌊 Breadth-First Search</h3>
                <p class="text-gray-300 mb-4">
                    BFS explores all neighbors at the current depth before moving deeper. It guarantees the shortest path in unweighted graphs.
                </p>
                <div class="space-y-2">
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">✅</span>
                        <span>Finds shortest path</span>
                    </div>
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">🔄</span>
                        <span>Uses queue (FIFO)</span>
                    </div>
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">⚡</span>
                        <span>Explores systematically</span>
                    </div>
                </div>
            </div>

            <div class="algo-card">
                <h3 class="text-2xl font-bold text-purple-400 mb-3">🌳 Depth-First Search</h3>
                <p class="text-gray-300 mb-4">
                    DFS explores as far as possible along each branch before backtracking. It may not find the shortest path but uses less memory.
                </p>
                <div class="space-y-2">
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">📚</span>
                        <span>Uses stack (LIFO)</span>
                    </div>
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">💾</span>
                        <span>Memory efficient</span>
                    </div>
                    <div class="flex items-center text-gray-400">
                        <span class="mr-2">🎯</span>
                        <span>May find path faster</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Instructions -->
        <div class="card p-6">
            <h2 class="text-2xl font-bold text-center mb-6 text-glow">🎮 How to Use</h2>
            <div class="grid md:grid-cols-2 gap-6 text-gray-300">
                <div>
                    <h3 class="font-semibold mb-3 text-blue-400">🎯 Grid Controls</h3>
                    <ul class="space-y-2">
                        <li>• Click 🏁 Start button, then click a cell to set start position</li>
                        <li>• Click 🎯 End button, then click on a cell to set end position</li>
                        <li>• Click 🧱 Wall button, then click and drag to draw walls</li>
                        <li>• Use 🎲 Generate Maze to create random mazes</li>
                        <li>• Use 🗑️ Clear to remove all walls</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold mb-3 text-purple-400">⚡ Algorithm Controls</h3>
                    <ul class="space-y-2">
                        <li>• Select your preferred algorithm (BFS/DFS)</li>
                        <li>• Adjust visualization speed with the slider</li>
                        <li>• Click ▶️ Start to begin the visualization</li>
                        <li>• Use ⏸️ Pause to pause/resume</li>
                        <li>• Click 🔄 Reset to clear the visualization</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Credits Footer -->
        <div class="credits-footer">
            <div class="credits-title">
                💻 Made with ❤️ by
            </div>
            <div class="credits-names">
                <div class="developer-card">
                    <div class="developer-name">Ashutosh Kumar</div>
                    <div class="developer-info">B.Tech CSE</div>
                    <div class="university">Lovely Professional University</div>
                </div>
                <div class="developer-card">
                    <div class="developer-name">Dhruv Singh</div>
                    <div class="developer-info">B.Tech CSE</div>
                    <div class="university">Lovely Professional University</div>
                </div>
            </div>
            <div class="text-sm text-gray-400 mt-4">
                🚀 Pathfinding Algorithm Visualization Project
            </div>
        </div>
    </div>

    <script>
        // Enhanced MazeVisualizer class with optimizations
        class MazeVisualizer {
            constructor() {
                this.EMPTY = 0;
                this.WALL = 1;
                this.START = 2;
                this.END = 3;
                this.VISITED = 4;
                this.PATH = 5;
                this.CURRENT = 6;

                this.gridSize = 15;
                this.grid = [];
                this.visualizationRunning = false;
                this.visualizationPaused = false;
                this.animationFrameId = null;
                this.timeoutIds = new Set();
                this.startPosition = null;
                this.endPosition = null;
                this.currentMode = 'wall';
                this.visitedCount = 0;
                this.pathLength = 0;
                this.isDragging = false;

                this.initializeDOM();
                this.bindEvents();
                this.initializeGrid(this.gridSize);
                this.createParticles();
                this.startBackgroundAnimation();
            }

            initializeDOM() {
                this.elements = {
                    gridContainer: document.querySelector('.grid-container'),
                    gridSizeSelect: document.getElementById('grid-size'),
                    generateMazeBtn: document.getElementById('generate-maze'),
                    addStartBtn: document.getElementById('add-start'),
                    addEndBtn: document.getElementById('add-end'),
                    addWallBtn: document.getElementById('add-wall'),
                    clearWallsBtn: document.getElementById('clear-walls'),
                    algorithmSelect: document.getElementById('algorithm'),
                    speedSlider: document.getElementById('speed'),
                    startBtn: document.getElementById('start'),
                    pauseBtn: document.getElementById('pause'),
                    resetBtn: document.getElementById('reset'),
                    stepsElement: document.getElementById('steps'),
                    visitedCountElement: document.getElementById('visited-count'),
                    pathLengthElement: document.getElementById('path-length'),
                    statusElement: document.getElementById('status')
                };
            }

            bindEvents() {
                this.elements.gridSizeSelect.addEventListener('change', () => {
                    this.initializeGrid(parseInt(this.elements.gridSizeSelect.value));
                });

                this.elements.generateMazeBtn.addEventListener('click', () => this.generateRandomMaze());
                this.elements.addStartBtn.addEventListener('click', () => this.setMode('start'));
                this.elements.addEndBtn.addEventListener('click', () => this.setMode('end'));
                this.elements.addWallBtn.addEventListener('click', () => this.setMode('wall'));
                this.elements.clearWallsBtn.addEventListener('click', () => this.clearWalls());
                this.elements.startBtn.addEventListener('click', () => this.handleStartClick());
                this.elements.pauseBtn.addEventListener('click', () => this.togglePause());
                this.elements.resetBtn.addEventListener('click', () => this.resetVisualization());

                // Mouse events
                document.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('cell')) {
                        this.isDragging = true;
                        this.handleCellInteraction(e.target);
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging && e.target.classList.contains('cell')) {
                        this.handleCellInteraction(e.target);
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                // Touch events
                document.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('cell')) {
                        e.preventDefault();
                        this.handleCellInteraction(e.target);
                    }
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (e.target.classList.contains('cell')) {
                        e.preventDefault();
                        this.handleCellInteraction(e.target);
                    }
                }, { passive: false });
            }

            createParticles() {
                const particlesContainer = document.getElementById('particles');
                const particleCount = window.innerWidth > 768 ? 50 : 20;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.width = Math.random() * 10 + 5 + 'px';
                    particle.style.height = particle.style.width;
                    particle.style.animationDelay = Math.random() * 20 + 's';
                    particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
                    particlesContainer.appendChild(particle);
                }
            }

            startBackgroundAnimation() {
                const shapes = document.querySelectorAll('.shape');
                shapes.forEach((shape, index) => {
                    shape.style.animationDelay = index * 2 + 's';
                });
            }

            setMode(mode) {
                this.currentMode = mode;
                
                // Reset all button states
                [this.elements.addStartBtn, this.elements.addEndBtn, this.elements.addWallBtn].forEach(btn => {
                    btn.classList.remove('ring-2', 'ring-offset-2', 'ring-blue-400');
                });

                // Highlight active button
                const activeBtn = mode === 'start' ? this.elements.addStartBtn : 
                                 mode === 'end' ? this.elements.addEndBtn : 
                                 this.elements.addWallBtn;
                activeBtn.classList.add('ring-2', 'ring-offset-2', 'ring-blue-400');
            }

            initializeGrid(size) {
                this.gridSize = size;
                this.grid = Array(size).fill().map(() => Array(size).fill(this.EMPTY));
                this.startPosition = null;
                this.endPosition = null;
                this.visitedCount = 0;
                this.pathLength = 0;
                this.updateStats();
                
                // Create grid with optimized rendering
                this.renderGrid();
                
                this.elements.statusElement.textContent = 'Ready';
                this.elements.statusElement.className = 'text-lg font-bold text-green-400';
            }

            renderGrid() {
                const fragment = document.createDocumentFragment();
                this.elements.gridContainer.innerHTML = '';
                
                // Create a proper grid layout
                this.elements.gridContainer.style.display = 'grid';
                this.elements.gridContainer.style.gridTemplateColumns = `repeat(${this.gridSize}, 30px)`;
                this.elements.gridContainer.style.gap = '1px';
                this.elements.gridContainer.style.justifyContent = 'center';
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        fragment.appendChild(cell);
                    }
                }
                
                this.elements.gridContainer.appendChild(fragment);
            }

            handleCellInteraction(cellElement) {
                if (this.visualizationRunning && !this.visualizationPaused) return;
                
                const row = parseInt(cellElement.dataset.row);
                const col = parseInt(cellElement.dataset.col);
                
                if (this.currentMode === 'start') {
                    this.setStartPosition(row, col);
                } else if (this.currentMode === 'end') {
                    this.setEndPosition(row, col);
                } else if (this.currentMode === 'wall') {
                    this.toggleWall(row, col);
                }
            }

            setStartPosition(row, col) {
                if (this.startPosition) {
                    const [prevRow, prevCol] = this.startPosition;
                    this.grid[prevRow][prevCol] = this.EMPTY;
                    this.updateCell(prevRow, prevCol);
                }
                
                this.grid[row][col] = this.START;
                this.startPosition = [row, col];
                this.updateCell(row, col);
            }

            setEndPosition(row, col) {
                if (this.endPosition) {
                    const [prevRow, prevCol] = this.endPosition;
                    this.grid[prevRow][prevCol] = this.EMPTY;
                    this.updateCell(prevRow, prevCol);
                }
                
                this.grid[row][col] = this.END;
                this.endPosition = [row, col];
                this.updateCell(row, col);
            }

            toggleWall(row, col) {
                if (this.grid[row][col] === this.START || this.grid[row][col] === this.END) return;
                
                this.grid[row][col] = this.grid[row][col] === this.WALL ? this.EMPTY : this.WALL;
                this.updateCell(row, col);
            }

            updateCell(row, col) {
                const cell = this.elements.gridContainer.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                
                // Use requestAnimationFrame for smooth updates
                requestAnimationFrame(() => {
                    cell.className = 'cell';
                    
                    switch(this.grid[row][col]) {
                        case this.START:
                            cell.classList.add('start');
                            break;
                        case this.END:
                            cell.classList.add('end');
                            break;
                        case this.WALL:
                            cell.classList.add('wall');
                            break;
                        case this.VISITED:
                            cell.classList.add('visited');
                            break;
                        case this.PATH:
                            cell.classList.add('path');
                            break;
                        case this.CURRENT:
                            cell.classList.add('current');
                            break;
                    }
                });
            }

            generateRandomMaze() {
                if (this.visualizationRunning) return;
                
                this.elements.generateMazeBtn.classList.add('loading');
                
                setTimeout(() => {
                    this.initializeGrid(this.gridSize);
                    
                    // Create maze using recursive backtracking
                    const mazeGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(this.WALL));
                    
                    const stack = [];
                    const startRow = 1;
                    const startCol = 1;
                    
                    mazeGrid[startRow][startCol] = this.EMPTY;
                    stack.push([startRow, startCol]);
                    
                    const directions = [[-2, 0], [0, 2], [2, 0], [0, -2]];
                    
                    while (stack.length > 0) {
                        const [row, col] = stack[stack.length - 1];
                        const neighbors = [];
                        
                        for (const [dr, dc] of directions) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (newRow > 0 && newRow < this.gridSize - 1 && 
                                newCol > 0 && newCol < this.gridSize - 1 && 
                                mazeGrid[newRow][newCol] === this.WALL) {
                                neighbors.push([newRow, newCol, row + dr/2, col + dc/2]);
                            }
                        }
                        
                        if (neighbors.length > 0) {
                            const [newRow, newCol, wallRow, wallCol] = neighbors[Math.floor(Math.random() * neighbors.length)];
                            mazeGrid[newRow][newCol] = this.EMPTY;
                            mazeGrid[wallRow][wallCol] = this.EMPTY;
                            stack.push([newRow, newCol]);
                        } else {
                            stack.pop();
                        }
                    }
                    
                    // Apply maze to grid
                    for (let i = 0; i < this.gridSize; i++) {
                        for (let j = 0; j < this.gridSize; j++) {
                            this.grid[i][j] = mazeGrid[i][j];
                            this.updateCell(i, j);
                        }
                    }
                    
                    this.setRandomStartEnd();
                    this.elements.generateMazeBtn.classList.remove('loading');
                }, 100);
            }

            setRandomStartEnd() {
                const emptyCells = [];
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j] === this.EMPTY) {
                            emptyCells.push([i, j]);
                        }
                    }
                }
                
                if (emptyCells.length < 2) return;
                
                const shuffled = emptyCells.sort(() => Math.random() - 0.5);
                const [startRow, startCol] = shuffled[0];
                const [endRow, endCol] = shuffled[1];
                
                this.setStartPosition(startRow, startCol);
                this.setEndPosition(endRow, endCol);
            }

            clearWalls() {
                if (this.visualizationRunning) return;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j] === this.WALL) {
                            this.grid[i][j] = this.EMPTY;
                            this.updateCell(i, j);
                        }
                    }
                }
            }

            handleStartClick() {
                if (this.visualizationRunning && this.visualizationPaused) {
                    this.togglePause();
                } else {
                    this.visualizeAlgorithm();
                }
            }

            async visualizeAlgorithm() {
                if (this.visualizationRunning || !this.startPosition || !this.endPosition) return;
                
                this.visualizationRunning = true;
                this.elements.startBtn.disabled = true;
                this.elements.pauseBtn.disabled = false;
                this.elements.statusElement.textContent = 'Running';
                this.elements.statusElement.className = 'text-lg font-bold text-blue-400';
                
                this.resetVisualization();
                
                const algorithm = this.elements.algorithmSelect.value;
                const speed = 110 - (this.elements.speedSlider.value * 10);
                
                try {
                    if (algorithm === 'bfs') {
                        await this.visualizeBFS(speed);
                    } else {
                        await this.visualizeDFS(speed);
                    }
                } catch (error) {
                    console.error('Visualization error:', error);
                } finally {
                    this.visualizationRunning = false;
                    this.elements.startBtn.disabled = false;
                    this.elements.pauseBtn.disabled = true;
                }
            }

            async visualizeBFS(speed) {
                return new Promise((resolve) => {
                    const [startRow, startCol] = this.startPosition;
                    const [endRow, endCol] = this.endPosition;
                    
                    const queue = [[startRow, startCol]];
                    const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                    visited[startRow][startCol] = true;
                    
                    const predecessors = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
                    let found = false;
                    
                    const processQueue = () => {
                        if (this.visualizationPaused) {
                            const timeoutId = setTimeout(processQueue, 100);
                            this.timeoutIds.add(timeoutId);
                            return;
                        }
                        
                        if (queue.length === 0 || found) {
                            if (found) {
                                this.backtrackPath(predecessors, [endRow, endCol], speed);
                            } else {
                                this.elements.statusElement.textContent = 'No Path Found';
                                this.elements.statusElement.className = 'text-lg font-bold text-red-400';
                            }
                            resolve();
                            return;
                        }
                        
                        const [row, col] = queue.shift();
                        
                        if (row === endRow && col === endCol) {
                            found = true;
                            const timeoutId = setTimeout(processQueue, speed);
                            this.timeoutIds.add(timeoutId);
                            return;
                        }
                        
                        if (this.grid[row][col] !== this.START && this.grid[row][col] !== this.END) {
                            this.grid[row][col] = this.VISITED;
                            this.visitedCount++;
                            this.updateCell(row, col);
                            this.updateStats();
                        }
                        
                        const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        
                        for (const [dr, dc] of directions) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (this.isValidCell(newRow, newCol) && 
                                !visited[newRow][newCol] && 
                                this.grid[newRow][newCol] !== this.WALL) {
                                
                                visited[newRow][newCol] = true;
                                predecessors[newRow][newCol] = [row, col];
                                queue.push([newRow, newCol]);
                            }
                        }
                        
                        const timeoutId = setTimeout(processQueue, speed);
                        this.timeoutIds.add(timeoutId);
                    };
                    
                    processQueue();
                });
            }

            async visualizeDFS(speed) {
                return new Promise((resolve) => {
                    const [startRow, startCol] = this.startPosition;
                    const [endRow, endCol] = this.endPosition;
                    
                    const stack = [[startRow, startCol]];
                    const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                    const predecessors = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
                    let found = false;
                    
                    const processStack = () => {
                        if (this.visualizationPaused) {
                            const timeoutId = setTimeout(processStack, 100);
                            this.timeoutIds.add(timeoutId);
                            return;
                        }
                        
                        if (stack.length === 0 || found) {
                            if (found) {
                                this.backtrackPath(predecessors, [endRow, endCol], speed);
                            } else {
                                this.elements.statusElement.textContent = 'No Path Found';
                                this.elements.statusElement.className = 'text-lg font-bold text-red-400';
                            }
                            resolve();
                            return;
                        }
                        
                        const [row, col] = stack.pop();
                        
                        if (visited[row][col]) {
                            const timeoutId = setTimeout(processStack, speed);
                            this.timeoutIds.add(timeoutId);
                            return;
                        }
                        
                        visited[row][col] = true;
                        
                        if (row === endRow && col === endCol) {
                            found = true;
                            const timeoutId = setTimeout(processStack, speed);
                            this.timeoutIds.add(timeoutId);
                            return;
                        }
                        
                        if (this.grid[row][col] !== this.START && this.grid[row][col] !== this.END) {
                            this.grid[row][col] = this.VISITED;
                            this.visitedCount++;
                            this.updateCell(row, col);
                            this.updateStats();
                        }
                        
                        const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
                        directions.sort(() => Math.random() - 0.5);
                        
                        for (const [dr, dc] of directions) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (this.isValidCell(newRow, newCol) && 
                                !visited[newRow][newCol] && 
                                this.grid[newRow][newCol] !== this.WALL) {
                                
                                predecessors[newRow][newCol] = [row, col];
                                stack.push([newRow, newCol]);
                            }
                        }
                        
                        const timeoutId = setTimeout(processStack, speed);
                        this.timeoutIds.add(timeoutId);
                    };
                    
                    processStack();
                });
            }

            isValidCell(row, col) {
                return row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize;
            }

            backtrackPath(predecessors, [endRow, endCol], speed) {
                const path = [];
                let current = [endRow, endCol];
                
                while (current && predecessors[current[0]][current[1]]) {
                    path.push(current);
                    current = predecessors[current[0]][current[1]];
                }
                
                path.reverse();
                
                let delay = 0;
                for (const [row, col] of path) {
                    if (this.grid[row][col] !== this.START && this.grid[row][col] !== this.END) {
                        const timeoutId = setTimeout(() => {
                            this.grid[row][col] = this.PATH;
                            this.pathLength++;
                            this.updateCell(row, col);
                            this.updateStats();
                            this.elements.statusElement.textContent = 'Path Found!';
                            this.elements.statusElement.className = 'text-lg font-bold text-green-400';
                        }, delay);
                        this.timeoutIds.add(timeoutId);
                        delay += speed * 0.5;
                    }
                }
            }

            resetVisualization() {
                this.timeoutIds.forEach(id => clearTimeout(id));
                this.timeoutIds.clear();
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                
                this.visualizationRunning = false;
                this.visualizationPaused = false;
                this.visitedCount = 0;
                this.pathLength = 0;
                this.updateStats();
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j] === this.VISITED || 
                            this.grid[i][j] === this.PATH || 
                            this.grid[i][j] === this.CURRENT) {
                            this.grid[i][j] = this.EMPTY;
                            this.updateCell(i, j);
                        }
                    }
                }
                
                this.elements.startBtn.textContent = '▶️ Start';
                this.elements.startBtn.disabled = false;
                this.elements.pauseBtn.disabled = true;
                this.elements.statusElement.textContent = 'Ready';
                this.elements.statusElement.className = 'text-lg font-bold text-green-400';
            }

            togglePause() {
                if (!this.visualizationRunning) return;
                
                this.visualizationPaused = !this.visualizationPaused;
                
                if (this.visualizationPaused) {
                    this.elements.pauseBtn.textContent = '▶️ Continue';
                    this.elements.statusElement.textContent = 'Paused';
                    this.elements.statusElement.className = 'text-lg font-bold text-yellow-400';
                } else {
                    this.elements.pauseBtn.textContent = '⏸️ Pause';
                    this.elements.statusElement.textContent = 'Running';
                    this.elements.statusElement.className = 'text-lg font-bold text-blue-400';
                }
            }

            updateStats() {
                requestAnimationFrame(() => {
                    this.elements.stepsElement.textContent = this.visitedCount + this.pathLength;
                    this.elements.visitedCountElement.textContent = this.visitedCount;
                    this.elements.pathLengthElement.textContent = this.pathLength;
                });
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new MazeVisualizer();
        });
    </script>
</body>
</html>
